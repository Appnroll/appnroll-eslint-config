"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var experimental_utils_1 = require("@typescript-eslint/experimental-utils");
var utils_1 = require("../utils");
var node_utils_1 = require("../node-utils");
exports.RULE_NAME = 'await-async-query';
var VALID_PARENTS = [
    'AwaitExpression',
    'ArrowFunctionExpression',
    'ReturnStatement',
];
var ASYNC_QUERIES_REGEXP = /^find(All)?By(LabelText|PlaceholderText|Text|AltText|Title|DisplayValue|Role|TestId)$/;
function isAwaited(node) {
    return VALID_PARENTS.includes(node.type);
}
function isPromiseResolved(node) {
    var parent = node.parent;
    if (node_utils_1.isCallExpression(parent)) {
        return node_utils_1.hasThenProperty(parent.parent);
    }
    return node_utils_1.hasThenProperty(parent);
}
function hasClosestExpectResolvesRejects(node) {
    if (!node.parent) {
        return false;
    }
    if (node_utils_1.isCallExpression(node) &&
        node_utils_1.isIdentifier(node.callee) &&
        node_utils_1.isMemberExpression(node.parent) &&
        node.callee.name === 'expect') {
        var expectMatcher = node.parent.property;
        return (node_utils_1.isIdentifier(expectMatcher) &&
            (expectMatcher.name === 'resolves' || expectMatcher.name === 'rejects'));
    }
    else {
        return hasClosestExpectResolvesRejects(node.parent);
    }
}
exports.default = experimental_utils_1.ESLintUtils.RuleCreator(utils_1.getDocsUrl)({
    name: exports.RULE_NAME,
    meta: {
        type: 'problem',
        docs: {
            description: 'Enforce async queries to have proper `await`',
            category: 'Best Practices',
            recommended: 'warn',
        },
        messages: {
            awaitAsyncQuery: '`{{ name }}` must have `await` operator',
        },
        fixable: null,
        schema: [],
    },
    defaultOptions: [],
    create: function (context) {
        var _a;
        var testingLibraryQueryUsage = [];
        var isQueryUsage = function (node) {
            return !isAwaited(node.parent.parent) &&
                !isPromiseResolved(node) &&
                !hasClosestExpectResolvesRejects(node);
        };
        return _a = {},
            _a["CallExpression > Identifier[name=" + ASYNC_QUERIES_REGEXP + "]"] = function (node) {
                if (isQueryUsage(node)) {
                    testingLibraryQueryUsage.push({ node: node, queryName: node.name });
                }
            },
            _a["MemberExpression > Identifier[name=" + ASYNC_QUERIES_REGEXP + "]"] = function (node) {
                var parent = node.parent;
                if (isQueryUsage(parent)) {
                    testingLibraryQueryUsage.push({ node: parent, queryName: node.name });
                }
            },
            _a['Program:exit'] = function () {
                testingLibraryQueryUsage.forEach(function (_a) {
                    var node = _a.node, queryName = _a.queryName;
                    var variableDeclaratorParent = node.parent.parent;
                    var references = (node_utils_1.isVariableDeclarator(variableDeclaratorParent) &&
                        context
                            .getDeclaredVariables(variableDeclaratorParent)[0]
                            .references.slice(1)) ||
                        [];
                    if (references && references.length === 0) {
                        context.report({
                            node: node,
                            messageId: 'awaitAsyncQuery',
                            data: {
                                name: queryName,
                            },
                        });
                    }
                    else {
                        for (var _i = 0, references_1 = references; _i < references_1.length; _i++) {
                            var reference = references_1[_i];
                            var referenceNode = reference.identifier;
                            if (!isAwaited(referenceNode.parent) &&
                                !isPromiseResolved(referenceNode)) {
                                context.report({
                                    node: node,
                                    messageId: 'awaitAsyncQuery',
                                    data: {
                                        name: queryName,
                                    },
                                });
                                break;
                            }
                        }
                    }
                });
            },
            _a;
    },
});
