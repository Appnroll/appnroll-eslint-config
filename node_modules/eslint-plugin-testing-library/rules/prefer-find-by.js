"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var experimental_utils_1 = require("@typescript-eslint/experimental-utils");
var node_utils_1 = require("../node-utils");
var utils_1 = require("../utils");
exports.RULE_NAME = 'prefer-find-by';
exports.WAIT_METHODS = ['waitFor', 'waitForElement', 'wait'];
exports.default = experimental_utils_1.ESLintUtils.RuleCreator(utils_1.getDocsUrl)({
    name: exports.RULE_NAME,
    meta: {
        type: 'suggestion',
        docs: {
            description: 'Suggest using find* instead of waitFor to wait for elements',
            category: 'Best Practices',
            recommended: 'warn',
        },
        messages: {
            preferFindBy: 'Prefer {{queryVariant}}{{queryMethod}} method over using await {{fullQuery}}'
        },
        fixable: 'code',
        schema: []
    },
    defaultOptions: [],
    create: function (context) {
        var sourceCode = context.getSourceCode();
        function reportInvalidUsage(node, _a) {
            var queryVariant = _a.queryVariant, queryMethod = _a.queryMethod, callArguments = _a.callArguments, caller = _a.caller;
            context.report({
                node: node,
                messageId: "preferFindBy",
                data: { queryVariant: queryVariant, queryMethod: queryMethod, fullQuery: sourceCode.getText(node) },
                fix: function (fixer) {
                    var newCode = "" + (caller ? caller + "." : '') + queryVariant + queryMethod + "(" + callArguments.map(function (node) { return sourceCode.getText(node); }).join(', ') + ")";
                    return fixer.replaceText(node, newCode);
                }
            });
        }
        return {
            'AwaitExpression > CallExpression': function (node) {
                if (!node_utils_1.isIdentifier(node.callee) || !exports.WAIT_METHODS.includes(node.callee.name)) {
                    return;
                }
                var argument = node.arguments[0];
                if (!node_utils_1.isArrowFunctionExpression(argument)) {
                    return;
                }
                if (!node_utils_1.isCallExpression(argument.body)) {
                    return;
                }
                if (node_utils_1.isMemberExpression(argument.body.callee) && node_utils_1.isIdentifier(argument.body.callee.property) && node_utils_1.isIdentifier(argument.body.callee.object) && utils_1.SYNC_QUERIES_COMBINATIONS.includes(argument.body.callee.property.name)) {
                    var queryMethod = argument.body.callee.property.name;
                    var caller = argument.body.callee.object.name;
                    reportInvalidUsage(node, {
                        queryMethod: queryMethod.split('By')[1],
                        queryVariant: getFindByQueryVariant(queryMethod),
                        callArguments: argument.body.arguments,
                        caller: caller,
                    });
                    return;
                }
                if (node_utils_1.isIdentifier(argument.body.callee) && utils_1.SYNC_QUERIES_COMBINATIONS.includes(argument.body.callee.name)) {
                    var queryMethod = argument.body.callee.name;
                    reportInvalidUsage(node, {
                        queryMethod: queryMethod.split('By')[1],
                        queryVariant: getFindByQueryVariant(queryMethod),
                        callArguments: argument.body.arguments,
                    });
                    return;
                }
            }
        };
    }
});
function getFindByQueryVariant(queryMethod) {
    return queryMethod.includes('All') ? 'findAllBy' : 'findBy';
}
