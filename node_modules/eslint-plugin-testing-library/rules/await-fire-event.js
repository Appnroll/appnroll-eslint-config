"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var experimental_utils_1 = require("@typescript-eslint/experimental-utils");
var utils_1 = require("../utils");
var node_utils_1 = require("../node-utils");
exports.RULE_NAME = 'await-fire-event';
var VALID_PARENTS = [
    'AwaitExpression',
    'ArrowFunctionExpression',
    'ReturnStatement',
];
function isAwaited(node) {
    return VALID_PARENTS.includes(node.type);
}
function isPromiseResolved(node) {
    var parent = node.parent.parent;
    return node_utils_1.isCallExpression(parent) && node_utils_1.hasThenProperty(parent.parent);
}
exports.default = experimental_utils_1.ESLintUtils.RuleCreator(utils_1.getDocsUrl)({
    name: exports.RULE_NAME,
    meta: {
        type: 'problem',
        docs: {
            description: 'Enforce async fire event methods to be awaited',
            category: 'Best Practices',
            recommended: false,
        },
        messages: {
            awaitFireEvent: 'async `fireEvent.{{ methodName }}` must be awaited',
        },
        fixable: null,
        schema: [],
    },
    defaultOptions: [],
    create: function (context) {
        return {
            'CallExpression > MemberExpression > Identifier[name=fireEvent]': function (node) {
                var memberExpression = node.parent;
                var fireEventMethodNode = memberExpression.property;
                if (node_utils_1.isIdentifier(fireEventMethodNode) &&
                    !isAwaited(node.parent.parent.parent) &&
                    !isPromiseResolved(fireEventMethodNode)) {
                    context.report({
                        node: fireEventMethodNode,
                        messageId: 'awaitFireEvent',
                        data: {
                            methodName: fireEventMethodNode.name,
                        },
                    });
                }
            },
        };
    },
});
